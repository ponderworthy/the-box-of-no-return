<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html lang="en">

<head>
    <title>mididings - Getting Started</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <link rel=stylesheet type="text/css" href="style.css">
</head>

<body>

<div class="nav">
    <a href="index.html">Index</a>
    <a href="index.html" class="navprev">Table of Contents</a>
    <a href="basics.html" class="navnext">Basics</a>
</div>

<h1>mididings - Getting Started</h1>


<h2><a name="anatomy"></a>Anatomy of a mididings script</h2>
<p>
mididings configuration files are just Python scripts, although some of Python's features are used in ways for which they weren't intended ;)<br>
Technically speaking, mididings is an embedded domain-specific language (DSL) based on Python.
</p>
<p>
The main difference between mididings and regular Python scripts is that mididings typically uses Python only at startup.
mididings patches consist of Python objects and nested data structures, but not actual Python code.
Internally, patches are converted to C++ objects, and the event processing is done entirely in C++.
It is however possible to call back into Python, if necessary.<br>
</p>
<p>
Although mididings is a Python module that can theoretically be imported in other Python applications, it's
really not designed to be used that way. Think of mididings as a standalone application, that just happens to
use Python as its "user interface".
</p>


<h2><a name="examples"></a>Examples</h2>

<h3><a name="example1"></a>Example 1</h3>
<p>
Let's start with something very simple:
</p>

<div class="example"><pre>
from mididings import *

run(Transpose(3))
</pre></div>

<p>
The import statement imports everything from the mididings Python module into the global namespace. The <b>run()</b> function is then used to
run a simple patch, in this case consisting of just a single Transpose() unit.<br>
<br>
You can start this script by saving it to a Python file and executing it, for example:
</p>

<div class="example">
$ python transpose.py
</div>

<p>
What this script does is to create an ALSA MIDI client with one input and one output port. It will then start listening for events on
the input port, transpose all incoming note-on and note-off events up by 3 semitones, and send all events to the output port.
Pressing Ctrl+C terminates the script.
</p>

<h3><a name="example2"></a>Example 2: connecting units</h3>

<p>
Ok, that was easy. Now let's try something slightly more complex:
</p>

<div class="example"><pre>
from mididings import *

config(
    backend='jack-rt',
    client_name='example',
)

run(
    Velocity(curve=1.0) &gt;&gt; [
        Transpose(12),
        Filter(NOTE|CTRL) &gt;&gt; Channel(3),
    ]
)
</pre></div>

<p>
The first thing that's new in this example is the <b>config()</b> function. This function is used to configure some global settings, and should
usually be called only once, at the start of the script. Here, it is used to select the JACK backend instead of ALSA, and to change the
JACK client name from 'mididings' to 'example'.
</p>

<p>
Now, let's look at the patch inside the <b>run()</b> function call. There are four mididings units used in this patch:
</p>
<ul>
    <li><b>Velocity(curve=1.0)</b>: applies a velocity curve to all note-on events, increasing their velocity values.</li>
    <li><b>Transpose(12)</b>: transposes all note events up by 12 semitones.</li>
    <li><b>Filter(NOTE|CTRL)</b>: removes all events that are not note-on, note-off or CC events.</li>
    <li><b>Channel(3)</b>: changes the MIDI channel of all events to channel 3.</li>
</ul>
<p>
Each of these units is quite simple on its own, but what's important is how the units are connected to each other:
</p>
<ul>
    <li><b>A &gt;&gt; B</b> connects two units in series, so every event output by unit A is then passed to unit B.</li>
    <li><b>[A, B, ...]</b> (which is just a list in Python) connects units in parallel, so each of these
        units gets its own copy of incoming events and processes them individually.</li>
</ul>

<p>
A graphical representation of the patch above would look something like this:<br>
<img src="patch.png" alt="Example patch">
</p>

<p>
For incoming note-on, note-off and CC events, this patch will output two events: one on the original MIDI channel,
with notes being transposed by one octave, and one on channel 3, with no transposition.
All other event types will result in only one event being sent to the output, because those event types are filtered out in
the lower branch of the patch, and thus never even reach the Channel() unit.
</p>


<h3><a name="example3"></a>Example 3: multiple scenes</h3>
<p>
Often it's desirable to run not just a single patch, but many different ones which can be switched using a
MIDI controller. With mididings it's possible to switch between an arbitrary number of "scenes", each of which
consists of one patch, and optionally an "init-patch" that will be triggered every time you switch to that scene.
</p>
<p>
Here's an example:
</p>

<div class="example"><pre>
from mididings import *

run(
    scenes = {
        1:  Scene("channel 1 only",
                Channel(1)
            ),
        2:  Scene("channel 2, program 23",
                Channel(2),
                Program(23) &gt;&gt; Channel(2)
            ),
        3:  Scene("channel 2, program 42",
                Channel(2),
                Program(42) &gt;&gt; Channel(2)
            ),
        4:  Scene("channel 1/3 split",
                KeySplit('c3',
                    Channel(1),
                    Channel(3)
                )
            ),
    },
    control = Filter(PROGRAM) &gt;&gt; SceneSwitch(),
    pre = ~Filter(PROGRAM),
)
</pre></div>

<p>
This script defines 4 <b>scenes</b>. In the first scene, all incoming events are simply routed to output channel 1.
In scenes 2 and 3, events are routed to channel 2. Additionally, when switching to one of these scenes,
MIDI program change messages will be sent on that channel first.
The fourth scene splits the keyboard at C3 and routes both regions of the keyboard to different output channels.
</p>
<p>
The <b>control</b> patch is used to switch between these scenes. The filter lets only program changes pass, which then
trigger the scene switches.<br>
In this example we assume that incoming program changes are only used for switching scenes, and should not be processed
by the currently active scene. Therefore the <b>pre</b> patch is used to filter out these events.
</p>

<p>
This is a complete overview of the event flow when using multiple scenes:
<img src="eventflow.png" alt="Event flow">
</p>
<p>
The control, pre and post patches as well as any of the init patches are optional and can be omitted.
The control patch can be used for any event processing that does not depend on the currently active scene.
</p>
<p>
Note that the use of init patches can often be significantly simplified by embedding them into the regular patches,
in particular using the Output() unit and the OutputTemplate class.
</p>


<h2><a name="commandline"></a>Command line usage</h2>

<p>
With the <b>mididings</b> command line application, simple patches can also be specified directly in your favorite shell,
so sometimes there's no need to write full-fledged Python scripts:
</p>

<div class="example">
$ mididings "Transpose(3) &gt;&gt; Channel(2)"
</div>

<p>
See '<kbd>mididings --help</kbd>' for more options.
</p>

<p>
It's also worth mentioning that mididings can easily be used in an interactive Python session:
</p>

<div class="example"><pre>
$ python -i -c "from mididings import *"
&gt;&gt;&gt; run(Transpose(3) &gt;&gt; Channel(2))
</pre></div>


<div class="nav">
    <a href="index.html">Index</a>
    <a href="index.html" class="navprev">Table of Contents</a>
    <a href="basics.html" class="navnext">Basics</a>
</div>

</body>

</html>
