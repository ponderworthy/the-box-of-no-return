<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html lang="en">

<head>
    <title>mididings - Core Module Reference</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <link rel=stylesheet type="text/css" href="style.css">
</head>

<body>

<div class="nav">
    <a href="index.html">Index</a>
    <a href="basics.html" class="navprev">Basics</a>
    <a href="units.html" class="navnext">Units Reference</a>
</div>

<h1>mididings - Core Module Reference</h1>


<h2><a name="functions"></a>Functions</h2>

<h4>config(**kwargs)</h4>
<p>
Changes global mididings settings. This should be called only once, before constructing any processing units.
<br>
Possible keyword arguments are:
</p>
<ul>
  <li><b>backend</b>: MIDI backend to be used:
    <ul>
      <li><b>'alsa'</b>: Use the ALSA sequencer (this is the default).</li>
      <li><b>'jack'</b>: Use JACK MIDI. All MIDI events are buffered and processed outside the JACK process callback,
      and will thus be delayed by (at least) one period.</li>
      <li><b>'jack-rt'</b>: MIDI events are processed directly in the JACK process callback. It's not safe to run Python
      code in a realtime context, so it's recommended to avoid Process(), which <i>might</i> cause xruns (or worse).
      All other units should be safe to use.</li>
    </ul>
  </li>
  <li><b>client_name</b>: MIDI client name to be used.</li>
  <li><b>in_ports / out_ports</b>: Defines the number and names of input and output ports, and optionally external
  ports to connect them to. Possible values are:
    <ul>
      <li>Integers: Simply indicates the number of ports to create (named in_<i>n</i> and out_<i>n</i>, respectively).
        <div class="example"><div class="header">
        Create two input ports with default names (in_1 and in_2):
        </div>
        config(in_ports=2)
        </div>
      </li>
      <li>Lists of ports, where each port is described by a string specifying its name, or a list/tuple containing the port name,
      followed by any number of regular expressions specifying ports to connect to.
      These regular expressions are matched against the full name (clientname:portname) of each external port.
      ALSA clients and ports can be specified using either their names or numbers.
        <div class="example"><div class="header">
        Create three output ports with custom names, and automatically connect two of those ports to other clients:
        </div>
        config(out_ports=[<br>
        &nbsp;&nbsp;&nbsp;&nbsp;'foo',<br>
        &nbsp;&nbsp;&nbsp;&nbsp;('bar', '24:0', 'yoshimi:midi in'),<br>
        &nbsp;&nbsp;&nbsp;&nbsp;('baz', 'LinuxSampler:.*'),<br>
        ])
        </div>
      </li>
    </ul>
  </li>
  <li><b>data_offset</b>: 1 (default) or 0. Determines whether program, port and channel numbers will be
  in the range 1-128 or 0-127.</li>
  <li><b>octave_offset</b>: Offset in octaves from note number 0 to C0.
  Default is 2, meaning that note number 24 (that is, two octaves up from 0) is designated as C0,
  and "middle C" (note number 60) is C3.</li>
  <li><b>initial_scene</b>: The number of the first scene to be activated.</li>
  <li><b>start_delay</b>: The number of seconds before sending any MIDI events (i.e. switching to the first scene).
  A small value like 0.5 can be used to give tools like qjackctl's patchbay time to connect the ports.
  A value of 0 instructs mididings to wait for the user to press enter. Default is None.</li>
</ul>


<h4>hook(*args)</h4>
<p>
Registers "hook" objects, that can be used to extend the functionality of mididings.
</p>


<h4>run(patch)</h4>
<p>
Starts the MIDI processing. This is usually the last function called by a mididings script.
</p>
<ul>
  <li><b>patch</b>: A single patch.</li>
</ul>

<h4>run(scenes=..., control=None, pre=None, post=None)</h4>
<p>
Starts the MIDI processing, using multiple scenes.
The SceneSwitch() unit can be used to switch between these scenes.
</p>
<ul>
  <li><b>scenes</b>: A dictionary with program numbers as keys, and Scene objects or plain patches as values.
  Values can also be tuples with two items, the first being an init-patch that's executed once every time the
  scenes is selected, and the second being the actual patch that processes incoming events.</li>
  <li><b>control</b>: The "control" patch, which is always active, and runs in parallel to the current scene.</li>
  <li><b>pre / post</b>: Allows processing to take place before/after every scene. Does not affect
  the control patch.</li>
</ul>


<h4>process_file(infile, outfile, patch)</h4>
<p>
<i>Requires mididings to be compiled with support for <a href="http://sourceforge.net/projects/libsmf/">libsmf</a>.</i><br>
Reads a standard MIDI file, processes it, then writes the result back to a file.
</p>


<h2><a name="classes"></a>Classes</h2>

<h4>Scene(name, patch, init_patch=None)</h4>
<p>
Constructs a Scene object to be used with the run() function.
</p>
<ul>
    <li><b>name</b>: A string describing the scene.</li>
    <li><b>patch</b>: The patch defining the MIDI processing to take place for incoming events.</li>
    <li><b>init_patch</b>: An optional patch that will be triggered when switching to this scene.</li>
</ul>

<h4>SceneGroup(name, [subscene, ...])</h4>
<p>
Constructs a SceneGroup object.
This can be used to group multiple scenes under a common name and program number.
Each of the subscenes should be a Scene object.
</p>
<div class="example"><div class="header">
Define one scene (song) with 3 subscenes (parts):
</div><pre>
SceneGroup("Example Song", [
    Scene("Intro", intro_patch),
    Scene("Verse", verse_patch),
    Scene("Chorus", chorus_patch),
])
</pre></div>


<h2><a name="constants"></a>Constants</h2>

<h3>Event Types</h3>
<p>
  Every event has one of these types:
</p>
<ul>
  <li><b>NOTEON</b></li>
  <li><b>NOTEOFF</b></li>
  <li><b>CTRL</b></li>
  <li><b>PROGRAM</b></li>
  <li><b>PITCHBEND</b></li>
  <li><b>AFTERTOUCH</b></li>
  <li><b>POLY_AFTERTOUCH</b></li>
  <li><b>SYSEX</b></li>
  <li><b>SYSCM_QFRAME</b></li>
  <li><b>SYSCM_SONGPOS</b></li>
  <li><b>SYSCM_SONGSEL</b></li>
  <li><b>SYSCM_TUNEREQ</b></li>
  <li><b>SYSRT_CLOCK</b></li>
  <li><b>SYSRT_START</b></li>
  <li><b>SYSRT_CONTINUE</b></li>
  <li><b>SYSRT_STOP</b></li>
  <li><b>SYSRT_SENSING</b></li>
  <li><b>SYSRT_RESET</b></li>
</ul>
<p>
  For use in filters, the following constants are also defined:
</p>
<ul>
  <li><b>NOTE</b> = NOTEON | NOTEOFF</li>
  <li><b>SYSCM</b> = SYSCM_*</li>
  <li><b>SYSRT</b> = SYSRT_*</li>
  <li><b>SYSTEM</b> = SYSEX | SYSCM | SYSRT</li>
  <li><b>NONE</b></li>
  <li><b>ANY</b></li>
</ul>
<p>
  Event types are bit masks, so when building filters, they can be combined using | (bitwise or) and ~ (bitwise negation).<br>
</p>

<h3>Event Attributes</h3>
<p>
  These constants are used by generator units and the SceneSwitch() unit to refer to an event's data attributes:
</p>
<ul>
  <li><b>EVENT_PORT</b></li>
  <li><b>EVENT_CHANNEL</b></li>
  <li><b>EVENT_DATA1</b></li>
  <li><b>EVENT_DATA2</b></li>
  <li><b>EVENT_NOTE</b></li>
  <li><b>EVENT_VELOCITY</b></li>
  <li><b>EVENT_CTRL</b></li>
  <li><b>EVENT_VALUE</b></li>
  <li><b>EVENT_PROGRAM</b></li>
</ul>


<div class="nav">
    <a href="index.html">Index</a>
    <a href="basics.html" class="navprev">Basics</a>
    <a href="units.html" class="navnext">Units Reference</a>
</div>

</body>

</html>
