<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html lang="en">

<head>
    <title>mididings - Basics</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <link rel=stylesheet type="text/css" href="style.css">
</head>

<body>

<div class="nav">
    <a href="index.html">Index</a>
    <a href="gettingstarted.html" class="navprev">Getting Started</a>
    <a href="core.html" class="navnext">Core Module Reference</a>
</div>

<h1>mididings - Basics</h1>


<h2><a name="connect"></a>Connections</h2>

<h3>Serial</h3>

<h4>A &gt;&gt; B<br>
Chain([ A, B, ... ])</h4>
<p>
Connects units in series. Incoming MIDI events will be processed by unit A first, then by unit B.
If the event is filtered out by unit A, it is not processed any further, and unit B will not be called.
</p>
<div class="example"><div class="header">
Transpose one octave down, then set channel to 1:
</div>
Transpose(-12) &gt;&gt; Channel(1)
</div>

<h3>Parallel</h3>

<h4>A // B<br>
[ A, B, ... ]<br>
Fork([ A, B, ... ], remove_duplicates=True)</h4>
<p>
Connects units in parallel. All units will be called with identical copies of incoming MIDI
events. The output will be the sum of all the units' outputs.
With Fork() it's also possible to disable the automatic removal of identical MIDI events by setting
remove_duplicates to False.
</p>
<div class="example"><div class="header">
Send events to both channels 1 and 2:
</div>
Channel(1) // Channel(2)
<br><br><div class="header">
or:
</div>
[ Channel(1), Channel(2) ]
</div>

<h4>+A</h4>
<p>
Applies A to a duplicate of each event and leaves the original unchanged.
Equivalent to [ Pass(), A ].
</p>

<h3>Splits</h3>

<h4>{ T1: A, T2: B, ... }<br>
Split({ T1: A, T2: B, ... })</h4>
<p>
Splits by event type.
Equivalent to [ Filter(T1) &gt;&gt; A, Filter(T2) &gt;&gt; B, ... ].
</p>
<div class="example"><div class="header">
Send note events to channel 1 and CC events to channel 2:
</div>
{ NOTE: Channel(1), CTRL: Channel(2) }
</div>

<h3>Filters</h3>

<h4>~F<br>
F.invert()</h4>
<p>
Inverts the filter F. Note that for filters which only affect certain kinds of events,
other events will remain unaffected when the filter is inverted.
For example, an inverted KeyFilter will match a different note range, but neither the original nor the inverted
filter will have any effect on controllers or program changes.
</p>
<div class="example"><div class="header">
Remove CC events with controller number 42:
</div>
~CtrlFilter(42)
</div>

<h4>-F<br>
F.negate()</h4>
<p>
Negates the filter F. Unlike ~F, this matches exactly the events that F doesn't.
</p>

<h3>Selectors</h3>

<p>
Every filter can act as a selector.
In addition, it's possible to combine multiple filters into more complex selectors:
</p>

<h4>S1 &amp; S2<br>
AndSelector([S1, S2, ...])</h4>
<p>
Builds a selector for events that match all of the given filters or selectors.
</p>

<h4>S1 | S2<br>
OrSelector([S1, S2, ...])</h4>
<p>
Builds a selector for events that match at least one of the given filters or selectors.
</p>

<h4>S % A<br>
S.apply(A)</h4>
<p>
Applies A only to events which match selector S, but keeps events which don't.
If S is a single filter, this is equivalent to [ S &gt;&gt; A, -S ].<br>
Note that operator % has higher precedence than &amp; and |, so the selector will usually have to
be written in parentheses.
</p>
<div class="example"><div class="header">
Transpose only events on channel 2:
</div>
ChannelFilter(2) % Transpose(3)
</div>
<div class="example"><div class="header">
Change CC events with controller number 23 or 42 from channel 1 to channel 2:
</div>
(ChannelFilter(1) &amp; (CtrlFilter(23) | CtrlFilter(42))) % Channel(2)
</div>


<h2><a name="notes"></a>Note names and ranges</h2>

<p>
Many mididings units accept notes and/or note ranges as parameters.
Notes can be specified either as a MIDI note number or by their name, consisting of one letter,
optionally 'b' or '#', and an octave number. Examples of valid note names are 'c3', 'g#4', 'eb2'.
</p>
<p>
Note ranges can be specified either as a 2-tuple of note numbers, e.g. (48, 60), or as two note names
separated by a colon, e.g. 'g#3:c6'. Like all ranges in Python, note ranges are semi-open (do not include
their upper limit), so 'g#3:c6' matches notes from 'g#3' up to 'b5', but not 'c6'!<br>
It's also possible to leave out either the upper or the lower limit, for example 'c4:' matches all notes above
(and including) C4, while ':a2' matches all note up to (but not including) A2.
</p>


<h2><a name="ports"></a>Port numbers and names</h2>

<p>
Internally, ports are always referred to by their number. When an event is received on the second input port,
and is not explicitly routed to another port, it will be sent to the second output port.<br>
If you named your input and output ports using the in_ports and out_ports parameters to config(), you can also refer
to them by their names in all units that accept ports as parameters.
To avoid ambiguities, port names should be unique (with the JACK backend they must be).
</p>


<h2><a name="misc"></a>Miscellaneous</h2>

<p>
A couple of things you might need to know...
</p>


<h3>Overloaded functions</h3>

<p>
Many function and unit names in mididings are overloaded to have somewhat different meanings depending on the number
and/or names of their parameters. For example, KeyFilter(note) filters a single note, while KeyFilter(lower, upper)
filters a range of notes.
</p>
<p>
When multiple versions of a unit accept the same number of parameters, it's necessary to explicitly name the parameters
of the version you'd like to use. Cases where parameter names are required are indicated in the documentation as "param=...".
It's usually possible to name parameters like this regardless of whether it's actually necessary.
</p>
<div class="example"><div class="header">
Add an offset of 42 to velocity values:
</div>
Velocity(42)
<br><br><div class="header">
Set velocities to a fixed value of 42:
</div>
Velocity(fixed=42)
</div>


<h3>Everything is an object</h3>

<p>
Everything in mididings is a Python object, and can be assigned to variables, returned from functions, etc.
</p>

<div class="example"><div class="header">
Add a fifth (7 semitones) above each note, route all events to channel 2 (of course there are easier ways to do this):
</div><pre>
def add_interval(n):
    return Pass() // Transpose(n)

route = Channel(2)
mypatch = add_interval(7) &gt;&gt; route

run(mypatch)
</pre></div>


<h3>Python syntax</h3>

<p>
In Python, line breaks delimit statements, and indentation delimits blocks. However, as a rule of thumb,
both are irrelevant as long as at least one parenthesis or bracket is still open.
Many mididings patches consist of lists and dictionaries, so line breaks and indentation are usually not an issue.
</p>
<p>
Sometimes it makes sense to put a patch in parentheses to allow it to span multiple lines:
</p>

<div class="example"><pre>
mypatch = (
    Transpose(12) &gt;&gt; Velocity(curve=1.0) &gt;&gt;
    Filter(~PROGRAM)
)
</pre></div>


<h3>Operator precedence</h3>

<p>
Overloading operators in Python does not change their precedence.
This is a list of all operators relevant to mididings, in order of their precedence (highest to lowest):
</p>

<table>
    <tr>
        <td><b>(...)<br>
            [A, B, ...]</b></td>
        <td>Binding (parentheses)<br>
            Connection in parallel (list)</td>
    </tr>
    <tr>
        <td><b>~F<br>
            -F<br>
            +F</b></td>
        <td>Filter inversion<br>
            Filter negation<br>
            Apply to duplicate</td>
    </tr>
    <tr>
        <td><b>A // B<br>
            S % A</b></td>
        <td>Connection in parallel<br>
            Selector &quot;then&quot;</td>
    </tr>
    <tr>
        <td><b>A >> B</b></td>
        <td>Connection in series</td>
    </tr>
    <tr>
        <td><b>F & G</b></td>
        <td>Selector &quot;and&quot;</td>
    </tr>
    <tr>
        <td><b>F | G</b></td>
        <td>Selector &quot;or&quot;</td>
    </tr>
</table>

<p>
<br>
In short, just remember that...
</p>

<ul>
    <li>parallel connection binds stronger than serial.</li>
    <li>selectors (of more than one filter) must be in parentheses.</li>
    <li>when in doubt, you can always use additional parentheses.</li>
</ul>

<p>
Also note that operators can't be overloaded if both sides are builtin Python types like lists or dictionaries.
In some cases it may be necessary to wrap those in Fork() or Split().
<p>


<div class="nav">
    <a href="index.html">Index</a>
    <a href="gettingstarted.html" class="navprev">Getting Started</a>
    <a href="core.html" class="navnext">Core Module Reference</a>
</div>

</body>

</html>
